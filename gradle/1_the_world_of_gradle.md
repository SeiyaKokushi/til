# Gradleの世界
## Gradleとは
　次世代のビルドツールとして注目を集めているオープンソースのプロダクト。Androidアプリケーション開発のビルドツールとして採用。  
　既存のビルドツールに比べて、優れている点が多い。  
　**Gradleのビルドスクリプトは非常にシンプルに記述できる。**  
　**Gradleは既存のAntタスクやAntビルドスクリプト、さらにMavenリポジトリを利用できる。**(MavenのプラグインはGradleから利用できない)  

### ビルドツールとは
　ソフトウェア開発においては、多くの定型的な作業が必要となる。  
　例えば、Javaアプリケーションの開発では...
- ソースコード(.java)をコンパイルしてクラスファイル(.class)を生成
- コーディング規約への適合性などをチェック
- ソースコードの静的解析を行う
- テストを実行してテスト結果やカバレッジ測定結果をレポートとして出力する
- Javadocなどのドキュメントを生成する
- クラスファイルやリソースファイルなどをパッケージングしてアーカイブ(.jarや.warなど)を生成する
- アーカイブをテスト環境やステージング環境などにリリースする
- アーカイブをリポジトリに登録する

　**ビルドツールとは、これらの定型的な作業を自動化するためのソフトウェア。**    

　ビルドツールを利用しない場合に直面する問題の例...
- ソースコードを修正してテストをするたびに手作業でコンパイル/テスト/パッケージング/リリースを行う必要があり、毎回時間と手間がかかる。さらに、手作業によるミスの発生が多い。
- 開発チームに新しいメンバーが参加したので、開発中のアプリケーションを試しに動かしてもらうことにした。しかし、作業手順が古く、ソースコードリポジトリからチェックアウトしてきた後の手順がうまくいかず、動かない。
- 開発者のローカルマシンではビルドが通るが、テスト環境ではビルドが失敗する。OSなどの環境が違うためだと思われるが、原因が分からない。
- プロジェクトのビルドに必要なオープンソースのライブラリを手動でダウンロードする必要があり、手間がかかる。そのライブラリが別のライブラリを要求、という様に依存関係を考慮しなければならず、必要な環境を整えるために何回もコンパイルして試行錯誤を繰り返すことになる。
- 開発したライブラリをオープンソースとして公開したが、ソースコードからバイナリを作る方法が難解で、なかなか使ってもらえない。  

　ビルドツールを適用することで、この様な問題のある程度を解決できる。
一般的なビルドツールでは、ビルドの順番をビルドスクリプトとして記述し、このスクリプトを解釈することで、様々な作業を自動化できる。
つまり、ビルド手順書が単なる**ドキュメントではなく、実行可能なプログラム**になる。  
　ビルド手順書が実行可能であることのメリット...
- 定型的な作業に人間が労力を費やす必要がなくなり、ミスが混在するリスクも排除できる。
- ビルドスクリプトが常に使われ、メンテナンスされることで、ドキュメントのように陳腐化するリスクが少ない。
- 環境の差異を認識して、環境ごとに異なる処理に対して条件分岐などで対応できる。  
　**"定型的な作業から人間を解放する"**→人間には人間にしかできない、より本質的な仕事に注力できるようになる。    

### ビルドツールの歴史
　ビルドツールは開発者にとっては縁の下の力持ち的な存在であり、比較的地味な存在。
しかし、時代の流れに伴って着実に発展している。

#### 元祖ビルドツール Make
　ソフトウェア開発の世界に**ビルド**という概念を初めて持ち込んだツール。  
　C言語などで開発されたソフトウェアのビルドにおいては、Makeはいまだ現役で使われている。
しかし、SConsなどの新しいビルドツールも登場。

#### Javaのためのビルドツール Ant
　Javaに適用するにはMakeではやや都合が悪い面があり、登場したのがAnt。  
　JavaとXMLを採用することで、Makeの弱点であったプラットフォーム依存から脱却。
Javaの流行と相まって、AntはJava系プロジェクトではデフォルトのビルドツールとしての地位を確立。
Make同様にいまだに現役。  
　Antが提供する機能はそれほど多くなく、シンプルで使いやすい反面、ちょっと複雑なことをしようとすると、ビルドスクリプトが長大になってしまい、メンテナンスが困難になる。
Javaでは豊富なライブラリを組み合わせて開発を行うのが一般的だが、Antにはライブラリの依存関係を管理する仕組みがなく、ライブラリの管理がビルド職人にとっては悩みの種だった。

#### ビルドツールの革新者 Maven
　Antの問題を解決すべく登場したのが、Maven。
JavaとXMLによるプラットフォーム独立のアーキテクチャはAntと同じ。
ビルドツールにビルドライフサイクルとプロジェクトオブジェクトモデル(POM)という概念を持ち込むことで、Antの弱点であった"ビルドスクリプトの冗長化"を解決。  
　また、POMにメタデータを持たせることで、ライブラリの依存関係を自動的に解決する仕組みを構築することに成功。  
　高性能である反面、暗黙的な規約を理解しなければならず、標準の規約から外れたことをしようとすると、途端に難易度が高くなる。

#### そして Gradle
　これまでのビルドツールの良い点やエコシステムを踏襲しつつ、欠点を解消することを目剤している新しいビルドツール。    

　Gradleまでの進化の流れ
1. Make: ビルドというコンセプトの確立
2. Ant: 凡用性を高める(=クロスプラットフォーム化)
3. Maven: ビルドスクリプトの記述を効率化する(=規約ベース)
4. Gradle: 柔軟性を高める(=スクリプト言語への回帰)

### Gradleの概要
　GradleプロジェクトのWebサイトでは、Gradleとは**Build Automation Evolved**、"ビルド自動化ツールの進化形"であると紹介されている。
この"進化"には次の2つの意味が込められている。
- Gradleは単なるビルド自動化だけでなく、テストの実行や成果物の公開、リリースなどのソフトウェア開発における各種タスクの自動化や、静的なWebサイトの生成、ドキュメントの生成といった、ソフトウェア開発以外のプロジェクトの自動化にも適用できる。
- GradleはAntの柔軟性、Mavenの依存性管理と規約といった過去のビルドツールの良い点を組み合わせ、さらにGroovy DSLなどのアイデアを投入することで、より効率的なビルドが行えるようにそれらを昇華させている。    

　Gradleの主な特徴
- 拡張可能なGradleビルド言語(DSL)の提供
- ビルドの分割や共通部品抽出などの体系化の容易さ
- IDEなどと連携するため、Gradleを外部からコントロールするためのAPIを提供
- インクリメンタルビルドや並列ビルドなどでビルドを効率化
- マルチプロジェクトサポートの柔軟性
- Maven/Ivyリポジトリからローカルファイルシステムまで多様な依存性管理手法に対応
- Antタスクだけでなく、Antプロジェクト全体とのインテグレーションに対応
- ビルドスクリプトの記述言語としてGroovyを利用
- Gradleラッパーによって、Gradleがインストールされていない環境でもビルドが実行可能
- 互換性への配慮    

　[Gradleプロジェクト公式Webサイト](http://www.gradle.org/)
ソースコードはGitHubで公開されている。  
　より詳しいGradleの内容は、ユーザーガイドを参照。  
　[Gradle User Guide](http://www.gradle.org/documentation/)  
　[Gradle ユーザーガイド(日本語翻訳版)](http://gradle.monochromeroad.com/docs/)

### Gradleの事例
　Gradleは比較的新しいプロダクトにも関わらず、多くのプロジェクトで利用されている。  
　Gradleは多くの企業やアプリケーションなどに採用されており、普及が進んでいくと予想される。  
　Gradle2.0以降では、C/C++/Objective-Cなどのネイティブ系言語のビルドや、Microsoft Visual Studioとの連携など、Javaのエコシステムを越えた機能強化が行われている。

## なぜGradleなのか?
　Gradleは既存のビルドツールの良い点をうまく継承しつつ、問題点を解決している。

### ビルドスクリプトの生産性の高さ
　Gradle→Mavenと同様、**規約ベースのビルド**  
よって、規約に従ったプロジェクト構造(ディレクトリ構造)を使う限りにおいては、ビルドスクリプトの記述を大幅に省略可能。
規約に外れる場合であっても、必要に応じてスクリプトを書き足すことで柔軟に対応可能。  
　GradleのベースはJVM言語であるGroovyであり、Groovyのメリットをそのまま使える。
Groovyの文法はJavaとほぼ同じで、リストリテラル/マップリテラル/クロージャといったJavaにはない便利な機能も持つため、簡単にビルドスクリプトが記述できる。  
　さらに、Gradleは単にGroovyの文法を使ってるだけでなく、ビルドスクリプトをより簡潔に記述するための独自の文法(DSL)も提供。  
　AntやMavenはXMLを利用してビルド言語を実装していたため、条件分岐や繰り返しなどの機能をAntやMavenが独自に実装する必要があった。
GradleはGroovy上で構築されているため、Groovyの提供する言語処理系の機能をそのまま使える。  
　GroovyはJavaVMさえあれば動作するので、特定のプラットフォームに依存しない形でビルドスクリプトを記述できる。

### ビルド手順の制御の容易性
　Mavenは"大半のプロジェクトに適用できる標準的なビルド手順"と"メタデータによるビルド手順の制御"という考えの具体的なアイデアとしてPOM(Project Object Model)を導入。  
　しかし、Mavenのビルド手順は追加や順序変更ができないため、Mavenの規約で想定されているビルド手順に合わないプロジェクトには対応できない。  
　GradleはMavenのように固定的なビルド手順を規定しておらず、ビルド手順はタスク(ビルド手順の各ステップ)の依存関係に基づいて決定される。  
　ユーザーがビルドスクリプト内でタスクの依存関係を構築し、その結果としてビルド手順が決定。
しかし、このままではAntの課題であった"ビルドスクリプトの冗長化"を解決できない。
そこで、Gradleではプラグインがタスクの依存関係のデフォルト構成を提供するようになっている。
あくまでこれはデフォルトの構成なので、カスタマイズしてビルド手順を変更できる。  
　Gradleは"カスタマイズ可能なデフォルトのビルド手順"を提供し、MavenとAntの中間的なアプローチを取れる。

### マルチプロジェクト対応
　以下の機能で、Gradleは複数のサブプロジェクトから構成されるプロジェクトのビルドをサポートする。  
- マルチプロジェクトに含めるサブプロジェクトを定義する機能
- サブプロジェクトに共通のビルドスクリプトを集約する機能
- サブプロジェクト間の依存関係を定義する機能
- 依存関係を考慮してインクリメンタルビルドする機能    

　複雑そうに見えるが、実際のビルドスクリプトは非常にシンプル。

### 部品化の気軽さ
　Gradleはビルドスクリプトの部品化の仕組みとして、カジュアルに使えるお手軽なものから、きっちり部品化して公開リポジトリで配布するレベルまで、幅広く柔軟に対応している。
- ビルドスクリプト内でのメソッドやクラスの抽出
- ビルドスクリプトの分割と再利用(apply fromによる読み込み)
- プロジェクト内限定で利用する拡張モジュール(buildSrcプロジェクト)
- 複数プロジェクトで凡用的に再利用するプラグイン    

　Gradleのいいところは、部品化のレベルを徐々にステップアップしていける点。

### 個別インストール不要
　AntやMavenはビルドスクリプトを配布するだけでなく、利用者の環境にAntやMavenをインストールしなければならないという点が問題。  
　この問題に対処するために、GradleはGradleラッパーという仕組みを提供している。Gradleラッパーはプロジェクト内にGradleのブートストラップを仕込むことで、指定されたバージョンのGradleを必要に応じて自動的にインストールして実行してくれる機能。  
　使い方  
1. Gradleのwrappaerタスクを実行してブートストラップを生成
2. これをSubversionやGitなどのバージョン管理システムに登録
3. 利用者がバージョン管理システムからプロジェクトをチェックアウトして、gradlewコマンドを実行
4. Gradleのバイナリがダウンロードされ、ビルドが行われる

### 互換性への配慮
　互換性に関するGradleの方針
- 既存の機能が突然使えなくなるような変更を行わない
- 機能を除去する場合は、将来的に廃止される可能性を明示して段階的に除去する
- 新機能は十分なフィードバックを受けて安定してから固定化する    

　これを実現するために、Gradleでは機能を次のライフサイクルに分類。  
- 非公開(internal)  
　Gradle自身が内部的に利用するための機能。ユーザガイドやDSLリファレンス、APIリファレンスなどのドキュメントに記載されない。
予告なしに変更される可能性があるため、ユーザが直接利用することは推奨されない。
ただし、ある機能が非公開(Internal)から公開(Public)に昇格することもある。  
- 実験的(Incubating)  
　新機能を試したいユーザにいち早く機能を提供するために、早い段階で提供される機能。
新機能の追加はまずこのステータスで行われ、既存の機能との統合や過去バージョンとの後方互換性などに関するフィードバックを受ける。
このステータスの機能は、公開(Public)ステータスに昇格するまで、Gradleのバージョンアップ時に変更される可能性がある。
その際、変更点はリリースノートに記載される。
このステータスにある機能は、ソースコードであれば**@Incubating**アノテーションでマークされ、ユーザーガイドでは"この機能は実験的(Incubating)ステータスにある"と記載される。  
- 公開(Public)  
　機能のデフォルトのステータス。非公開(Internal)でも実験的(Incubating)でもない機能が該当する。
ユーザガイド、DSLリファレンス、APIリファレンスなどのドキュメントで明示的に"実験的(Incubating)"ないし"廃止(Deprecated)"と記載にないものは全てこのステータス。
実験的(incubating)ステータスから公開(Public)ステータスに昇格した場合、リリースノートに記載される。
このステータスの機能は削除されたり変更されたりすることはなく、削除される場合は一旦"廃止(Deprecated)"ステータスに移行する。  
- 廃止(Deprecated)  
　Gradleのバージョンアップに伴って不要になったり、新しい機能で置き換えられた機能は廃止(Deprecated)ステータスを経て段階的に除去される。
このステータスの機能を利用することは避けるべき。
廃止(deprecated)ステータスに移行した機能は、ソースコード上では@Deprecatedアノテーションでマークされる。
このステータスの機能を利用すると、Gradle実行時に警告が出る。    

　Gradleの後方互換性ポリシー
- Gradleはメジャーバージョンアップを通じて後方互換性を維持するよう努める
- 公開(Public)ステータスの機能は明示的に廃止(Deprecated)ステータスに移行しない限り、除去されることはない
- 廃止(Deprecated)ステータスに移行した機能は次のメジャーバージョンアップの時に除去される。

## 他のビルドツールとの比較
### Make vs Gradle
　Makeはビルドツールの草分け的な存在。
特にC言語といったネイティブ向けソフトウェア開発の現場では未だに現役。  
　Makeの特徴は、Makefileと言うビルドスクリプトを記述することで、成果物を生成するための作業と、その作業同士の関連性を定義できるようになっていること。  
　これによるメリット...  
- ビルド手順をシェルスクリプトなどでスクラッチから実装する必要がない
- "更新されたCソースと、それに依存するソースの身を選択的にビルドする"というように、ビルドの効率性を高めることができる    

　Make自体の機能は非常にコンパクトで基本的にはある成果物を生成するためのコマンドやシェルスクリプトを定義するだけ。
そのため、ビルドで行えることの自由度は比較的高いものの、その特性上プラットフォームへの依存が高くなる。
　また、Makeには依存性解決の機能はない。  
　GradleはMakeの持つ"スクリプトベースの柔軟性"を取り戻しつつ、クロスプラットフォーム対応や依存性解決、規約ベースのビルドなどのモダンなビルドツールに求められる要件を満たしたものと位置付けられる。

### Ant vs Gradle
　AntはJavaのテーゼである"Write Once, Run Anywhere"を実現したビルドツール。
Makeの課題である"クロスプラットフォーム対応"を解決するために、プラットフォーム依存を回避できるJavaとXMLを基盤として構築された。  
　Makeよりは高機能だが、Antもビルドツールとしての機能は比較的シンプルなものだった。
しかし、Antは使うための敷居が低かったこと、Javaのビルドツールとしては他に選択肢がなかったことからデファクトスタンダードとなった。
Antは拡張性が容易であったため、多くの拡張タスクが作られ、エコシステムが強化された。    
　Antの課題...  
- 基本機能がシンプルなため、複雑なことをしようとすると、ビルドスクリプトがめちゃくちゃ長くなる
- ディレクトリ構造などの標準規約がなく、プロジェクトごとに異なるビルドスクリプトが乱立してしまい、再利用が難しい
- ライブラリの依存性管理を行う機構が無く、依存ライブラリを自分でダウンロードしてくる必要がある
- ビルドスクリプト述語言語としてXMLベースのDSLを採用したことが制約になって、Makeのようにスクリプト言語を駆使した柔軟な処理を行うことが難しい
- XML自体には自然言語処理系としての機能はないため、新たな言語処理系を実装する必要がある    

　GradleはAntのシンプルさやクロスプラットフォーム性を踏襲しつつ、以下のものを実現した。  
- GroovyベースのDSLを採用してビルドスクリプトで柔軟な処理が可能に
- 依存性解決や規約ベースのビルドの機能を盛り込んでより使いやすく

### Maven vs Gradle
　Mavenは規約ベースのビルドや依存性解決など、ビルドに新しい概念をもたらした革命的ツール。  
　Mavenが導入した"規約ベースのビルド"というアプローチにおいては、プロジェクトのタイプ別にディレクトリ構造やビルド手順が標準化される。
この標準規約に従う限り、詳細なビルド内容を指示しなくてもビルドが行えるため、ビルドスクリプトの簡略化とプロジェクトの再利用性の向上に大きく貢献。    

　Mavenのデメリット...
- 使いこなすためにはMavenの複雑な規約を理解する必要があり、初学者にとっては敷居が高い
- 規約に合わないプロジェクトでは極端に難易度が高くなる(あるいは適用できない)    

　Mavenのビルドスクリプトの記述にはAntと同様にXMLベースのDSLが採用されていて、ビルドスクリプトの柔軟性という面では大きな制約を受けている。  
　Mavenの機能は基本的にはプラグインとして実装されていて、プラグインの実体はJavaクラス。
Mavenはビルドスクリプト述語言語としてXMLを採用したため、Mavenのビルドスクリプト内で記述できるのは次の2つ。  
- どのプラグインを実行対象として構成するかを指定
- プラグインに渡すパラメータを指定    

　原則としてビルドスクリプト内にロジックを直接記述することはできない。
そのため、Mavenの既存のプラグインで提供されていない機能を実現したい場合には、プラグインを開発することがほぼ必須となる。
Mavenプラグインの開発は比較的難易度が高く、Mavenが敷居が高いと言われる要因の一つ。  
　一方、GradleのビルドスクリプトはGroovyベースであるため、次のようなことが簡単に実現できる。  
- ビルドスクリプト内に処理を直接記述する
- ビルドスクリプト内でJavaクラスを直接利用する  
　そのため、ビルドスクリプト内でGradleの提供するAPIを呼び出し、Gradleの提供する機能を直接利用できる。
わざわざプラグインを開発しなくても、Gradleのパワーを直接引き出したり、拡張したりすることが容易に実現できる。  
　つまり、GradleはMavenと同様に規約ベースのビルドや依存性解決の仕組みを提供しつつも、Mavenよりも柔軟にカスタマイズや拡張が可能なビルドツールである。

